<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>基本</title>
    <style>
        div>ul>li{
            text-align: center;
            list-style: none;
        }
        div>ul>li>img{
            width: 300px;
            height: 300px;
            vertical-align: middle;
        }
    </style>
</head>
<!-- <div style="display: flex;">
    <div style="flex: 1;background: yellow;">123</div>
    <div style="flex: 2;background: green;">123</div>
    <div style="flex: 1;background: red;">
    <div>啊啊啊</div>
    <div>阿斯顿发放</div>
    <div>阿斯顿发放</div>
    <div>阿斯顿发放</div>
</div> -->
<body>
    <div>
        <ul>
            <li>
                <img data-src="https://sf3-scmcdn2-tos.pstatp.com/xitu_juejin_web/img/logo.a7995ad.svg" alt="">
            </li>
            <li>
                <img data-src="https://sf3-scmcdn2-tos.pstatp.com/xitu_juejin_web/img/logo.a7995ad.svg" alt="">
            </li>
            <li>
                <img data-src="https://sf3-scmcdn2-tos.pstatp.com/xitu_juejin_web/img/logo.a7995ad.svg" alt="">
            </li>
            <li>
                <img data-src="https://sf3-scmcdn2-tos.pstatp.com/xitu_juejin_web/img/logo.a7995ad.svg" alt="">
            </li>
            <li>
                <img data-src="https://sf3-scmcdn2-tos.pstatp.com/xitu_juejin_web/img/logo.a7995ad.svg" alt="">
            </li>
            <li>
                <img data-src="https://sf3-scmcdn2-tos.pstatp.com/xitu_juejin_web/img/logo.a7995ad.svg" alt="">
            </li>
            <li>
                <img data-src="https://sf3-scmcdn2-tos.pstatp.com/xitu_juejin_web/img/logo.a7995ad.svg" alt="">
            </li>
        </ul>
    </div>
</body>

<body>
    <div>
        <!-- 1、call，apply，bind -->
    </div>
</body>

</html>
<!-- <script>
    // 图片的懒加载
window.onload = function (){
    const imgs = document.querySelectorAll('img')
    lazyImg(imgs)
}
const lazyImg = (imgs) => {
    console.log(imgs)
    const io =  new IntersectionObserver((entries,observes)=>{
        entries.forEach(entry=>{
            if(entry.isIntersecting){
                const img = entry.target
                console.log(entry.boundingClientRect)
                img.setAttribute('src',img.dataset.src)
                img.onload = img.onerror = () => io.unobserve(img)
            }
        })
    })
    imgs.forEach(item=>{
        io.observe(item)
    })
}
</script> -->
<!-- <script>
    
function _call(content = window, ...arg){
    const fn = Symbol();
    content[fn] = this;
    const result = content[fn](...arg);
    delete content[fn]
    return result
}


function _apply(content = window, arg){
    const fn = Symbol();
    content[fn] = this;
    const result = content[fn](arg);
    delete content[fn]
    return result
}
function _bind(content = window, ...arg){
    if(typeof content !== 'function'){
        throw new Error('必须是function')
    }
    const self = this;
    const result = function (...arg1){
        return self.call(this instanceof self ? this : content, ...arg, ...arg1) 
    }
    return result
}

// var tea = {
//     value: '奶茶'
// }
// function drink(name) {
//     console.log(`${name} drink ${this.value}`);
// }
Function.prototype._bind = function (content){
    const self = this;
    if(typeof self !== 'function'){
        throw new Error('must a function')
    }
    let arg1 = Array.prototype.slice.call(arguments, 1)
    const result = function(){
        arg1.concat(Array.prototype.slice.call(arguments))
        return self.apply(this instanceof result ? this :content, arg1)
    }
    result.prototype = Object.create({})
    return result
}
// const bar = function() {
//   console.log(this.name, arguments);
// };
// bar.prototype.name = 'bar';
// const foo = {
//   name: 'foo'
// };
// const bound = bar._bind(foo, 22, 33, 44);
// bound(123)
// const fn = drink.bind(tea, 111,123)
// fn()
// this.x = 9;    // 在浏览器中，this 指向全局的 "window" 对象
// var module = {
//   x: 81,
//   getX: function() { return this.x; }
// };
// var abc = module.getX;
// var newAbc = abc.bind(module)
// console.log(abc())
// console.log(newAbc())

// var obj = {
//     a:1,
//     f:function(){
//         return arguments
//     }
// }
// console.log(obj.f)
/* var s = Symbol('name')
const s1 = Symbol('name')
var obj = {
    1: 'a',
    2: 'b',
    4: 'c'
}
obj[s] = 1
console.log(obj)
console.log(s.description===s1.description)
console.log(s1.description) */

// function Food(){
//    console.log('123')
// }
// var food1 = new Food()
// function debounce(fn, time){
//     let timer = null;
//     return function(){
//         if(timer){
//             clearTimeout(timer)
//         }
//         timer = setTimeout(()=>{
//             fn.apply(this,arguments)
//         },time)
//     }
// }

// function throttle(fn, time){
//     let st = new Date()
//     return function(){
//         let et = new Date();
//         if(et-st>time){
//             fn.apply(this, arguments)
//             st = et
//         }
//     }
// }

// // 手动实现一个sleep函数
// function sleep(time){
//     return new Promise((resolve, reject)=>{
//         setTimeout(()=>{
//             resolve()
//         },time)
//     })
// }
// const abc = (name) =>{ console.log(name)}
// async function autoRun(){
//     await sleep(2000);
// }

// autoRun();


// 1、只是匹配 /某个字符/.test()
// 2、匹配某个字符开头  ^
// 3、某个字符结尾 $
// 4、匹配多个字符 [某个字符某个字符]
// 5、匹配某个字符串 /str|str/

// const str1 = 'ajavascript';
// const str2 = 'javascriptaaaaa';
// console.log(/^a/.test(str))  
// console.log(/a$/.test(str2))
// console.log(/[xz]/.test(str1))

// console.log(/ja|aa/.test(str2))

//  箭头函数和普通函数的区别
// 1、this的问题，箭头函数的this指向创建的时候的this。
// 2、没有arguments，但是可以通过扩展运算符来拿到传参。
// 3、没有prototype属性。
// 4、不能作为构造函数使用。

// 函数式编程compose
// 就像reduce

// const arr = [
//     {
//         name: '小红',
//         age: 18,
//         fraction: 58
//     },
//     {
//         name: '小王',
//         age: 18,
//         fraction: 61
//     },
//     {
//         name: '小挣',
//         age: 16,
//         fraction: 53
//     },
// ]

// const arr = [1,2,2,3,1,2,3,4,,5,5,6,6,6,7,7]
// console.log('it' in arr)
// console.log(arr.reduce((a,b)=>a+b))
// const arr1 = Array.from(new Set(arr));
// console.log(arr - arr1)

// const arr2 = arr.reduce((pre,cur)=>{
//     if(pre.indexOf(cur)=== -1){
//         pre.push(cur)
//     }
//     return pre
// }, [])
// console.log(arr2)

// const arr2 = arr.reduce((pre,cur)=>{
//     if(cur in pre){
//         pre[cur]++
//     }else{
//         pre[cur] = 1
//     }
//     return pre
// },{})
// console.log(arr2)


// 一个简单的compose

// const reducer = ((pre, cur)=> x => pre(cur(x)))
// const compose = ['fn1','fn2'].reduce(reducer)

// const arr1 = [1,2,3],arr2 = [1,4,6,'1'];

// let temp = []
// arr1.map(item=>{
//     if(arr2.indexOf(item)!== -1){
//         temp.push(arr2[arr2.indexOf(item)])
//     }
// })
// console.log(temp)

// const arr = arr1.concat(arr2)
// console.log(arr)
// const res = arr.reduce((pre,cur)=>{
//     if(cur in pre){
//         pre[cur]++
//     }else {
//         pre[cur] = 1
//     }
//     return pre
// },{})
// let temp = []
// for(item in res){
//     if(res[item]>1){
//         temp.push(item)
//     }
// }
// console.log(temp)

// const temp = arr1.filter(item=>arr2.indexOf(item)> -1)
// console.log(temp)

// const arr = [
//     {
//         id: 0,
//         name: '0',
//         parent: null
//     },
//     {
//         id: 1,
//         name: '1',
//         parent: 0
//     },
//     {
//         id: 2,
//         name: '2',
//         parent: 1
//     },
//     {
//         id: 3,
//         name: '3',
//         parent: 1
//     }
// ]



// let obj1 = {
//     a: 1
// }
// Object.seal(obj1)
// obj1.b = 2
// console.log(obj1.b)

// 实现一个Promise
function _Promise(fn){
    const self = this;
    self.status = 'pendding'
    self.success = undefined
    self.error = undefined
    function resolve(value){
        if(self.status === 'pendding'){
            self.status = 'resolved'
            self.success = value
        }
    }
    function reject(value){
        if(self.status === 'pendding'){
            self.status = 'rejected'
            self.error = value
        }
    }
    try{
        fn(resolve,reject)
    } catch(err){
        reject(err)
    }
}
_Promise.prototype.then = function (onResolved, onRejected){
    let self = this;
    if(self.status === 'resolved'){
        onResolved(self.success)
    }
    if(self.status === 'rejected'){
        onRejected(self.error)
    }
}
// _Promise.prototype.all = function (){

// }

// const promise = new Promise((resolve,reject)=>{
//     let a = 2
//     if(a > 5){
//         resolve(a)
//     }else{
//         reject(a)
//     }
// })
// promise.then(item=>{
//     console.log(item)
// }).catch(err=>{
//     console.log(err)
// })



// let p1 = new Promise(resolve=>{
//     resolve(1)
// })
// let p3 = new Promise(reject=>{
//     reject(3)
// })
// let p2 = new Promise(resolve=>{
//     resolve(2)
// })
// let p = Promise.all([p1,p2,p3]).then(value=>{
//     console.log(value)
// })

document.cookie = 'name=12333'


// const obj1 = {
//     name: 1,
//     value: 2,
// }
// const obj2 = {
//     name: 1,
//     value: 2
// }
// console.log(Object.is(obj1,obj2))

// console.log(-0 === +0)
// console.log(Object.is(0,-0))



const trees = [{
    id: 0,
    name: 0,
    children: [
        {
            id: 1,
            name: 1,
            children: [
                {
                    id: 2,
                name: 2,
                children: []
                },
                {
                    id: 3,
                    name: 3,
                    children: []
                }
            ]
        },

        {
            id: 4,
            name: 4,
            children: [
                {
                    id: 5,
                name: 5,
                children: [
                    {
                        id: 7,
                        name: 7,
                        children: []
                    }
                ]
                },
                {
                    id: 6,
                    name: 6,
                    children: []
                }
            ]
        }
    ]
}]
console.log(trees)
function travelTrees(data){
    if(!data||!data.length) return
    for(let i = 0;i<data.length;i++){
        var childs = data[i].children
        console.log(data[i].id)
        if(childs&&childs.length>0){
            travelTrees(childs)
        }
    }
}
// travelTrees(trees)


// var salesOffices = {};  // 发布者

// salesOffices.clientList = [];  // 订阅的用户

// salesOffices.listen = function(fn) {  
//   this.clientList.push(fn);
// }
// function getData(req) {
//         const random = Math.random(0, 10) * 100
//         // fetch 返回promise 为了测试写成这样
//         return new Promise((resolve) => {
//             setTimeout(() => {
//                 resolve(req)
//             }, random)
//         })
//     }

// salesOffices.listen(function(price, squareMeter) {
//   console.log(`价格${price}`);
// })
// const obj = {
//     obj1: {
//         obj2: {
//             name: 2
//         },
//         name: '1',
//     }
// }
// const proxy = new Proxy(obj, 'obj1', {
//     get(target,key){

//     },
//     set(target,)
// })


// add(1)(2)(3) ====> 6
// add(1,2)(3) ====> 6
// add(1,2,3) ====> 6

// const adds = (a,b,c) => a+b+c
// const curry = (fn) =>{
//     let params = [];
//     const next = (...arg)=>{
//         params = [...params,...arg];
//         if(fn.length>params.length){
//             return next
//         }else{
//             return fn.apply(fn,params)
//         }
//     }
//     return next
// }
// function curry(fn, arg) {
//           arg = arg || [];
//           let length = fn.length;
//           if (typeof fn !== 'function') return false
//           return function () {
//               let newArg = arg.concat(Array.prototype.slice.call(arguments));
//               if (newArg.length < length) {
//                   return curry.call(this,fn,newArg)
//               }else{
//                   return fn.apply(this,newArg)
//               }
//           }
//       }

// const curry = (fn) =>{
//     if(fn.length===1) return fn
//     const next = (...arg) =>{
//         if(fn.length===arg.length){
//             return fn(...arg)
//         }else{
//             return (...arg1) =>{
//                 return next(...arg,...arg1)
//             }
//         }
//     }
//     return next
// }

// const add = curry(adds);
// console.log(add(1,2,3))
// console.log(add(1)(2)(3))
// console.log(add(1,2)(3))
// console.log(add(1,2,3))

// const arg = [1,2,3]
// const arg1 = arg.map(item => item + 1)
// console.log(arg1)

// Array.prototype.map = function(fn){
//     return 1
// }
// const arg1 = arg.map()

// console.log(arg1)
</script> -->

<script>
    // 研究一下arguments这个东西
    // const fn = (...arg)=>{
    //     console.log(arg)
    // }
    // fn(1)
    // 箭头函数没有arguments

    // const fn = function (){
    //     console.log(arguments)
    //    console.log(Array.from(arguments))
    //    console.log([...arguments])
    //    console.log(Array.prototype.slice.call(arguments))
    //    console.log(Array.prototype.slice.apply(arguments))
    //    console.log([].slice.apply(arguments))
    // }
    // fn(1,2,3)
</script>