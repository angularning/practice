<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body style="font-size: 16px;">
<div style="width: 100%;height:300px;background: #fff;" id="deBox">
    滑过我，打印1
</div>
<!--<h3>第七题双向绑定</h3>-->
<!--<p id="value"></p>-->
<!--<input type="text" id="valueInput" onkeyup="updateValue(event)" placeholder="更新上面p的值">-->
</body>
</html>
<script type="application/javascript">
    console.log([...document.querySelectorAll('*')])
    // 第一题：几个异步处理的执行顺序
    /* async function a1() {
         console.log(1);
         await a2();
         console.log(3)
     }
     async function a2() {
         console.log(2)
     }
     Promise.resolve().then(()=>{
         console.log(4)
     })
     setTimeout(()=>{
         console.log(5)
     })
     a1();
     console.log(6)*/
    // 第二题：ES6属性表达式
    /* let a={a:10},b={b:20},obj={a:10};
     obj[b]=20;
     console.log(obj[a])*/
    // 第三题：数组去重
    /*Array.prototype.qcArr=function () {
        let self=this,res=[];
        for(let i=0;i<self.length;i++){
            for(let j=i+1;j<self.length;j++){
                if(self[i]===self[j]){
                    i++;
                    j=i
                }
            }
            res.push(self[i])
        }
        return res
    }
    let arr1=[1,2,3,1,3];
    // console.log(arr1.qcArr())

    Array.prototype.qcArr1=function () {
        let self=this,res=[];
        for(let i=0;i<self.length;i++){
            if(res.indexOf(self[i])<0){
                res.push(self[i])
            }
        }
        return res
    }
    // console.log(arr1.qcArr1())

    Array.prototype.qcArr2=function () {
        let self=this,res=[],obj={};
        for(let i=0;i<self.length;i++){
            if(!obj[self[i]]){
                res.push(self[i])
                obj[self[i]]=1
            }
        }
        return res
    }
    // console.log(arr1.qcArr2())

    Array.prototype.qcArr3=function () {
        return [...new Set(this)]
    }
    // console.log(arr1.qcArr3())

    Array.prototype.qcArr4=function () {
        let self=this,res=[];
        for(let v of self){
            if(!res.includes(v)){
                res.push(v)
            }
        }
        return res

    }

    */

    // 第四题：深拷贝和浅拷贝区别和实现
    // 浅拷贝和深拷贝都是针对于引用数据类型
    // 浅拷贝只是简单的复制操作，如果旧数据发生改变，拷贝得来的新数据也会改变
    // 深拷贝得到的数据并不会随着旧数据的改变而改变。
    // 一般都是对于Array，Object Array里自带的一些方法能实现一维数组的深拷贝 ，Array.slice(),Array.concat(),Array.from()
    // Object里自带的 Object.assign(); JSON.parse(JSON.stringify()) 不能复制 undefined,Symbol(),Function;
    // function clone(target) {
    //     let result;
    //     if(Array.isArray(target)){
    //         result=target
    //     }else{
    //         result={}
    //     }
    //     for(let i in target){
    //         result[i]=target[i]
    //     }
    //     return result
    // }
    /*
     //Object.assign
     let obj1={name:1,age:18};
     console.log(obj1)
     let newObj1={};
     obj1.name=2
     Object.assign(newObj1,obj1)
     console.log(newObj1)

     */

    /*
    // JSON.parse(JSON.stringify())
    let obj2={
        a:'小红',
        b:function () {},
        c:undefined,
        d:null,
        e:Symbol(),
        f:[1,2,3],
        g:{
            a:1,
            b:[1,2,3]
        }
    }

     let newObj2=JSON.parse(JSON.stringify(obj2));
     obj2.a='xiaozhang'
     console.log(obj2)
     console.log(newObj2)
     */
    /*
       // 深拷贝的函数版
        function deepClone(target){
            let result=Array.isArray(target)?[]:{};
            if(target&& typeof target==="object"){
                for(let i in target){   //也会循环继承的属性
                    if(target.hasOwnProperty(i)){  //判断是不是自身的属性，而不是继承属性
                        if(target[i]&&typeof target[i]==='object'){ //判断对象属性是不是数组或者对象
                            result[i]=this.deepClone(target[i])  //递归处理把值复制过去
                        }else{
                            result[i]=target[i]  //直接赋值
                        }
                    }
                }
            }
            return result
        }

        let obj3={
            a:'小红',
            b:function () {},
            c:undefined,
            d:null,
            e:Symbol(),
            f:[1,2,3],
            g:{
                a:1,
                b:[1,2,3]
            }
        }

        let newObj3=deepClone(obj3)
        obj3.d=undefined
        console.log(obj3)
        console.log(newObj3)*/

    // 第五题：call，apply，bind的区别，用处，以及如何手动实现
    // call，apply，都是为了改变this的指向，用法基本相同，唯一的区别是，call的参数是多个字符串。apply是数组
    // 举例：
    /*var a=2;
    let person={
        a:1,
        b:function () {
            console.log(this.a)
        }
    }
    function ab() {
        console.log(arguments)
        var a=3;
        console.log(this.a)
    }
    ab() //2
    ab.call(person,1,2,3,4)  // 1
    ab.apply(person,[1,2,3]) //1
    ab.bind(person,1,2,3,4)()*/
    // 手动实现call
    /* Function.prototype._call=function (context=window,...arg) {
         let _fn=Symbol()
         context[_fn]=this;
         context[_fn]();
         let result=context[_fn](...arg);
         delete context[_fn]
         return result
     }
     var a=2;
     let p={
         a:1,
         b:function () {
             console.log(arguments);
             console.log(this.a)
         }
     }
     p.b._call(this,1,2,3)*/

    //实现apply
    /* Function.prototype._apply=function (context = window, arg) {
         let fn=Symbol(),result;
         context[fn]=this;
         if(Array.isArray(arg)){
             result= context[fn](...arg)
         }else{
             throw new Error('TypeError,参数需为Array')
         }
         delete context[fn]
         return result
     }
     var a=2;
     let p={
         a:1,
         b:function () {
             console.log(arguments);
             console.log(this.a)
         }
     }
     p.b._apply(this,1,2)*/

    // 手动实现 bind
    //  思考
    /*Function.prototype._bind=function (context = window, ...arg) {
        if(typeof this !=='function'){
            throw new Error('需要是function')
        }
        let self=this;
        let fn=function(...arg1){
            if(self instanceof fn){
                return new self.apply(...arg,...arg1)
            }else{
                return self.apply(context,arg.concat(...arg1))
            }
        }
        return fn
        // res=context[fn]()
    }
    var a=2;
    let t={a:1}
    function a1() {
        console.log(this.a)
    }
    a1._bind(t)()*/


    // 第六题：如何判断引用数据类型
    /*
       var checkType=Object.prototype.toString;
       console.log(checkType.call(2))
       console.log(checkType.call(Symbol()))

       */
    // 第七题：数据双向绑定的原理以及实现
    // 在vue中数据是双向绑定的，比如model上的数据直接会更新在view上，view发生改变，也会提现在model上
    // 如何实现双向绑定呢，在vue2.0之前是使用Objec.defineProperty,在vue3.0则使用 Proxy
    // 例子：
    /* let objValue={
         value:''
     }
     function updateValue(e) {
         objValue.value=e.target.value;
     }
     Object.defineProperty(objValue,'value',{
         get() {
             return value
         },
         set(v) {
             value=v;
             document.getElementById('valueInput').value=v;
             document.getElementById('value').innerHTML=v;
         }
     })*/

    /* let objValue={}
     let newObj=new Proxy(objValue,{
         get(target, p, receiver) {
             return Reflect.get(target,p,receiver)
         },
         set(target, p, value, receiver) {
             if(p==='value'){
                 document.getElementById('valueInput').value=value;
                 document.getElementById('value').innerHTML=value;
             }
             return Reflect.set(target,p,value,receiver)
         }
     })

     function updateValue(e) {
         newObj.value=e.target.value;
     }
 */
    // 第八题：parseInt()
    // parseInt(string,radix) ,第二个参数如果不写或者为0，按照10来处理，如果不在2-36之间，则返回NaN，如果以0x，oX，开头以16为基准
    /*
        let str1=['1','2','3','4','5',6,7,8,9,10,11,12,13,14,15];
        console.log(str1.map((item,key)=>{return parseInt(item,key)}));   //[1, NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN, 9, 11, 13, 15, 17, 19]
        // parseInt("10",10)
            // 1*10^1+0*10^0=10           128+8+2
        console.log(parseInt('212',8))
        // 2*8^2+1*8^1+2*8^0=138
        //     1*2^2+1*2^1+1*2^0=7;
    */

    // 第九题：手动封装一个请求，设置最大请求次数
    /*  let data11={"link":'https://v.douyin.com/QCQ6L7/'}
      const fetchInit = {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
          },
          body: JSON.stringify(data11), // "{"name":"Billy","age":18}"
      };
      const fetchInit1 = {
          method: 'POST',
          headers: {
              'Content-Type': 'application/xxx',
          },
          // body: formatData(data), // "{"name":"Billy","age":18}"
      };*/
    function request(url, body, successCallback, errCallback, maxRequest = 0) {
        return fetch(url).then(res => {
            successCallback(res)
        }).catch(err => {
            if (maxRequest <= 1) {
                return errCallback(err)
            } else {
                return request(url, body, successCallback, errCallback, --maxRequest)
            }
        })
    }

    //
    var codeJson = '{"mobile":"' + 13511111111 + '","version":"' + 1111 + '","password":"' + 123456 + '","plat":"' + 3 + '"}';
    /*
    $.ajax({
        type:'post',
        url:ONLINEURL+'login.do?data='+codeJson,
    // url:'http://webtest.yqbing.com/login.do?data='+codeJson,*/
    // request('https://api-sv.videoparse.cn/api/video/parse',codeJson,{},res=>{
    //     console.info(res.json())
    //     // console.log(JSON.stringify())
    // },err=>{
    //     console.log(err)
    // })

    // 第十题：js的节流和防抖
    // 先描述一下节流和防抖用到的场景，大多数针对于那些经常触发的事件，比如浏览器滚动，按钮频繁点击
    /*
    function debounce(fn,wait,now) {   // 防抖
        let res;
        return function () {
            let self=this,arg=arguments;
            if(res) clearTimeout(res);
            if(now){
                let fres=!res;
                res=setTimeout(function () {
                    res=null
                },wait)
                if(fres){
                    fn.apply(self,arg)
                }
            }else{
                res=setTimeout(function () {
                    fn.apply(self,arg)
                },wait)
            }

        }
    }
    let NUM=1;
    let doSome=function(){
        console.log(NUM++)
    }
    document.getElementById('deBox').addEventListener('mousemove',debounce(doSome,1000,true))
    防抖的特点是在wait时间内如果多次触发，并不会真正执行，而是最后一次执行
    */
    /*
        function jl(fn, wait, now) {
            let times=(new Date()).getTime();

        }*/

    // 第十一题：对比一下目前主流的浏览器缓存的优缺点，使用场景等等
    // localStorage,sessionStorage,cookie
    // localStorage存储的数据是永久的，存储的数据量比较大，不会随着用户关闭浏览器，客户端消失。
    // sessionStorage存储的数据是会话级别的，关闭当前窗口则清空，存储的数据量也大。
    // cookie，主要用于与服务端通信，可以设置过期时间，数据存储量比较小。
    /*
        localStorage.getItem('name');
        localStorage.setItem('name',1)

        sessionStorage.getItem('name')
        sessionStorage.setItem('name',2)

        // cookie没有类似上面的方便的封装，可以自己封装一个
        function setCookie(n,v,t){
            let time=new Date();
            time.setDate(time.getDate()+t);
            time.toUTCString();
            document.cookie=''+n+'='+v+';expires='+time
        }
        setCookie('one',121,'1')

        console.log(getCookie('one'))
        function getCookie(n) {
            const c=document.cookie;
            const nc=c.split(';');
            let res='';
            console.log(nc)
            for(v of nc){
                if(v.indexOf(n)>-1){
                    res= v.substr(v.indexOf('=')+1,v.length)
                }
            }
            return res
        }
        function delCookie(n) {
            document.cookie=''+n+'="";expires=-1'
        }*/

    // 第十二题：函数的柯里化的通用实现，实现 add(1)(2)(3)=6  add(1,2)(3)=6 add(1,2,3)=6
    // 柯里化从概念上来讲就是把接受多个参数的函数转化为接受单一的参数，并返回一个函数作为结果。从表现上看如下：
    /*function some(x) {
        return function (y) {
            return x+y
        }
    }*/
    /*
        function curry(fn, arg) {
            const fnLen = fn.length, self = this;
            arg = arg || [];
            return function () {
                const newArg = Array.prototype.slice.apply(arguments, 1);
                Array.prototype.push.call(newArg, arg);
                if (newArg.length < fnLen) {
                    return curry.apply(this, fn, newArg)
                } else {
                    return fn.call(this, newArg)
                }
            }
        }

        // adder(1,2,3),adder(1)(2)(3),adder(1,2)(3)
        function adder() {
            const arg = [...arguments];
            console.log('1------------------1')
            console.log(arg)
            const _arg = function () {
                arg.push(...arguments);
                return _arg
            };
            console.log('2------------------2')
            _arg.toString=function () {
                return arg.reduce(function (a, b) {
                    return a+b
                })
            }
            return _arg
        }
    */

    // 第十三题：继承的实现
    // 原型链继承，构造函数继承，组合继承，ES6的extends继承
    // 说道继承就肯定会提到 原型，原型链，构造函数，实例，实例对象

    /*  function F(){}
      var f = new F();
      // 构造函数 F
      F.prototype.constructor === F; // true
      F.__proto__ === Function.prototype; // true
      Function.prototype.__proto__ === Object.prototype; // true
      Object.prototype.__proto__ === null; // true

      // 实例 f
      f.__proto__ === F.prototype; // true
      F.prototype.__proto__ === Object.prototype; // true
      Object.prototype.__proto__ === null; // true*/

    /*
    // 原型链继承：
    function Parent(name){
        this.name=name;
    }
    Parent.prototype.getName=function () {
        console.log(this.name)
    };
    const Child=function () {}
    Child.prototype=new Parent('小小');
    const newChild=new Child();
    console.log(newChild.name);
    newChild.getName()
    console.log(Child.prototype.__proto__===Parent.prototype)
    console.log(newChild.__proto__==Child.prototype)

    */
    // 构造函数继承：
    /*  function Parent() {
          const parent='A'
          console.log(parent)
      }
      function Son() {
          Parent.call(this,[...arguments])
      }
      // Son()
      const newSon=new Son();*/
    // 组合继承就是把 原型继承和构造函数继承使用在一起
    /*  function Parent(name) {
          this.name=name;
      }
      function Son(name) {
          Parent.call(this,name)
      }
      Parent.prototype.getName=function(){
          console.log()
      }
      Son.prototype=new Parent();
      Son.prototype.constructor=Son;

      class f1{
          constructor(name){
              this.name=name
          }
      }*/

    // 未完待续

    // 手动实现 async 和await

    /*async function f1() {
        console.log(1)
        await f2()
        console.log(2)
    }
    function f2() {
        console.log(3)
    }
    console.log(4)
    setTimeout(function () {
        console.log(5)
    })*/
    /*
    const promise = new Promise((resolve, reject) => {
         console.log(1)
         resolve()
         console.log(2)
     })
     promise.then(() => {
         console.log(3)
     })
     console.log(4)
     */

    /*  const promise1 = new Promise((resolve, reject) => {
          setTimeout(() => {
              resolve('success')
          }, 1000)
      })
      const promise2 = promise1.then(() => {
          throw new Error('error!!!')
      })

      console.log('promise1', promise1)
      console.log('promise2', promise2)

      setTimeout(() => {
          console.log('promise1', promise1)
          console.log('promise2', promise2)
      }, 2000)

      // promise1 Promise { <pending> }
      // promise2 Promise { <pending> }
      // (node:50928) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: error!!!
      // (node:50928) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.
      // promise1 Promise { 'success' }
      // promise2 Promise {
      //   <rejected> Error: error!!!
      //     at promise.then (...)
      //     at <anonymous> }

      promise的状态只能由pending -> resolve 或者到 reject，不能逆转，切 promise内部是同步的，只有 .then 或者 .catch是异步执行的。
     */
    /* const promise = new Promise((resolve, reject) => {
         resolve('success1')
         reject('error')
         resolve('success2')
     })
     promise
         .then((res) => {
             console.log('then: ', res)
         })
         .catch((err) => {
             console.log('catch: ', err)
         })
     promise 的状态改变只会执行第一次
   // then success1
   */

    /*   Promise.resolve(1)
           .then((res) => {
               console.log(res)
               return 2
           })
           .catch((err) => {
               return 3
           })
           .then((res) => {
               console.log(res)
           })

       // promise 是链式调用，每次调用 then后返回了一个新的 promise
       // 1，2*/


    /* const promise = new Promise((resolve, reject) => {
         setTimeout(() => {
             console.log('once')
             resolve('success')
         }, 1000)
     })

     const start = Date.now()
     promise.then((res) => {
         console.log(res, Date.now() - start)
     })
     promise.then((res) => {
         console.log(res, Date.now() - start)
     })
     // promise 的状态改变之后，多次执行 then，也是在上次的结果上执行的，执行需要一定的时间，可能会有1毫秒的差别。

     // once success 1004  success 10005*/
    /*

        Promise.resolve()
            .then(() => {
                return new Error('error!!!')
            })
            .then((res) => {
                console.log('then: ', res)
            })
            .catch((err) => {
                console.log('catch: ', err)
            })
        // 错误需要由 reject来抛出来。return 无效
        // then error!!!
    */

    /*
    const promise = Promise.resolve()
        .then(() => {
            return promise
        })
    promise.catch(console.error)

    // 报错 then 或者 catch 返回的值不能释怀promise 自身
*/

    /* Promise.resolve(1)
         .then(2)
         .then(Promise.resolve(3))
         .then(console.log)


         // promise then接受的是一个函数。
     // 1*/

    /*
        Promise.resolve()
            .then(function success (res) {
                console.log('success1')
                throw new Error('error')
            }, function fail1 (e) {
                console.log('fail1')
                console.error('fail1: ', e)
            })
            .catch(function fail2 (e) {
                console.error('fail2: ', e)
            })

        // 只有catch 能捕获错误
        // fail2 error
        */

    // 第十四题：说下对闭包的理解，以及用处。
    // 闭包指的是某个函数内能访问另一个作用域的变量。那就不得不说到作用域的概念，从字面上理解就是变量声明的位置，js使用的是词法作用域，
    // 也叫做静态作用域，
    // 作用域举例：
    /* function A() {
         let str='1';
         let B=function () {
             console.log(B)
         }
         return B
     }
     let C=A();
     C();*/



    // 闭包比如：
    /*function b() {
        var a=1;
        function c() {
            console.log(a)
        }
        c()
    }
    b();*/
    /* function A() {
         let a = 1
         function B() {
             console.log(a)
         }
         return B
     }*/
    /*  for ( var i=1; i<=5; i++) {
          setTimeout( function timer() {
              console.log( i );
          }, i*1000 );
      }*/

    /*   for ( var i=1; i<=5; i++) {
           (function (j) {
               setTimeout( function timer() {
                   console.log( j );
               }, j*1000 );
           })(i)

       }
   */

    // 十五：instanceOf的原理和实现
    //    说起来 这个instanceof 对比的是 typeof
    //    js的数据类型大致分为两种 基本数据类型和引用数据类型

    // String, Number, Boolean, Symbol, null undefined
    //     Array  Object
    // 比如我要判断某个值是什么类型的，如果是基本类型 用typeOf就能准确的判断出来，但是如果是引用数据类型就无法判断因为返回的都是object，
    // 所以就要使用到instanceOf,那么它是靠什么得到我们想要的结果呢 他是查找原型链，判断这个的原型链上是不是纯在这种类型的

    /*  var arr1=[1,2,3,4];
      var fn1=function(){};
      console.log(typeof arr1)
      console.log(typeof fn1)
      console.log(arr1 instanceof Array)
      // Object.prototype.toString.call(data)
      checkType(arr1)
      function checkType(data) {
          console.log(Object.prototype.toString.call(data))
      }


  */

    /*  // 实现 instanceof
      let arr1=[1,2,3,4,undefined,null];
      let obj1={"a":[1,2,4]}

      function _instanceof(left,right) {
          let _right=right.prototype;
          let _left=left.__proto__;
          while(true){
              if(_left===_right){
                  return true
              }
              if(_right===null){
                  return  false
              }
              _left=_left.__proto__;
          }
      }
      console.log(arr1 instanceof Array);
      console.log(_instanceof(arr1,Array))
  */









    /*

        document.addEventListener('DOMContentLoaded',function () {
            alert(1)
        })
    */





    /*  // 发送消息端
      window.parent.postMessage('message', 'http://baidu.com');
      // 接收消息端
      var mc = new MessageChannel();
      mc.addEventListener('message', (event) => {
          var origin = event.origin || event.originalEvent.origin;
          if (origin === 'http://baidu.com') {
              console.log('验证通过')
          }
      });
  */
    /* var self=this;

     // index.js
     if (navigator.serviceWorker) {
         navigator.serviceWorker
             .register('sw.js')
             .then(function(registration) {
                 console.log("service worker 注册成功");
             })
             .catch(function(err) {
                 console.log("servcie worker 注册失败");
             });
     }
     // sw.js
     // 监听 `install` 事件，回调中缓存所需文件
 */
    /* af();
    function af() {
        setInterval(function () {
            document.getElementById('deBox').style.background=color16();
            function color16(){//十六进制颜色随机
                var r = Math.floor(Math.random()*256);
                var g = Math.floor(Math.random()*256);
                var b = Math.floor(Math.random()*256);
                var color = '#'+r.toString(16)+g.toString(16)+b.toString(16);
                return color;
            }
        },2000)

    }*/

    // 第十六题：vue和react的生命周期的理解   暂缓

    // 第十六题： 手动实现的promise

  /*  function myPromise(constructor) {
        let _this = this;
        this.status = 'pending';
        this.resolveValue = undefined;
        this.rejectValue = undefined;

        function resolve(resolveValue) {
            if (_this.status === 'pending') {
                _this.status = 'resolved';
                _this.resolveValue = resolveValue;
            }
        }

        function reject(rejectValue) {
            if (_this.status === 'pending') {
                _this.status = 'rejected';
                _this.rejectValue = rejectValue;
            }
        }

        try {
            constructor(resolve, reject);
        } catch (e) {
            reject(e)
        }
    }

    myPromise.prototype.then = function (onFullfilled, onRejected) {
        let _this = this;
        switch (_this.status) {
            case "resolved":
                onFullfilled(_this.resolveValue);
                break;
            case "rejected":
                onRejected(_this.rejectValue);
                break;
            default:
        }
    }

    let myp=new myPromise(function (resolve, reject) {
        resolve(1)
    });
    myp.then(res=>{
        console.log(res)
    })
*/


</script>

