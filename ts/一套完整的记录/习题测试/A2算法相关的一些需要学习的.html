<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0;">
    <title>需要学习的知识</title>
</head>
<body>
<div>
    <iframe src="https://www.lovestu.com/api/project/cnmapyinqing/obj.php" height="500" frameborder="no" border="0"
            width="100%"></iframe>

    <ul>
        <li>
            1、冒泡排序
        </li>
        <li>
            2、快速排序
        </li>
        <li>
            3、插入排序
        </li>
        <li>
            3、树型相互转化
        </li>
        <li>
            4、123456789 1 0 1 1 1 2 1 3 1 4 1 5 161718192021....n;输出第m位是多少
            10,11,12,13,14,15,16,17,18,19,20,21
            0, 1 2 3 4 5 6 7 8 9 10
        </li>
    </ul>
</div>
</body>
</html>
<script>

    //  1，2，3，4，    5，   6
    // 16，17，18，19，20，   7
    // 15， 24，23 ，22 ，21，8
    // 14 13，12，11， 10，   9
    // n *(n-1)*(n-2)... 2*1


    let arr1 = [1, 2, 5, 4, 3];

    // 1、冒泡的思想是左边和右边相比，把小的和大的交换位置。
    function mp(arr) {
        let len = arr.length;
        for (let i = 0; i < len; i++) {
            for (let j = 0; j < len; j++) {
                if (arr[j] > arr[j + 1]) {
                    [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
                }
            }
        }
        return arr
    }
    // console.log(mp(arr1))


    // 2、选择排序的特点是，假设第一个是最小的，依次去剩下的和最小的比，如果更小则把当前元素设为最小的，如果最小的元素不等于刚开始设置的最小的，则循环交换位置。
    function xz(arr) {
        let len = arr.length;
        for (let i = 0; i < len; i++) {
            let min = i;
            for (let j = i; j < len; j++) {
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }
            if (min !== i) {
                [arr[i], arr[min]] = [arr[min], arr[i]]
            }
        }
        return arr
    }

    // console.log(xz(arr1))

    // 3、插入排序的思想是，从第二个元素开始，依次循环使用右边的元素和左边的元素相比较，调整位置。要注意移动元素的位置

    function cr(arr) {
        let len = arr.length;
        for (let i = 1; i < len; i++) {
            let temp = arr[i];
            let j = i - 1;
            while (arr[j] > temp) {
                arr[j + 1] = arr[j];
                j--
            }
            arr[j + 1] = temp;
        }
        return arr
    }

    // 这三种排序方式多用于教学或者展示，在实际生产生活中，用不多。

    //4、 归并排序是一种 先分在和的思想，把数据分成一个一个的单独的数据，然后在进行比较合并。

    function f1(arr) {
        if(arr.length<2) return arr;
        let mid=Math.floor(arr.length/2);
        let leftArr=arr.slice(0,mid);
        let rightArr=arr.slice(mid,arr.length);
        return f2(f1(leftArr),f1(rightArr));
    }
    function f2(left, right) {
        let result=[];
        while(left.length>0&&right.length>0){
            if(left[0]<=right[0]){
                result.push(left.shift())
            }else{
                result.push(right.shift())
            }
        }
        while(left.length){
            result.push(left.shift())
        }
        while(right.length){
            result.push(right.shift())
        }
        return result
    }

    // console.log(    f1(arr1))

    // 5、快速排序的特点是找到一个临界点，把数据分成两部分，
    function kxpx(arr) {
        if(arr.length<=1) {return arr}
        let p=Math.floor(arr.length/2);
        let left=[];
        let right=[];
        let pIn=arr.splice(p,1)[0];
        for(let i=0;i<arr.length;i++){
            if(arr[i]<pIn){
                left.push(arr[i])
            }else{
                right.push(arr[i])
            }
        }
        return kxpx(left).concat([pIn],kxpx(right));
    }
    var quickSort = function(arr) {

        if (arr.length <= 1) { return arr; }

        let pivotIndex = Math.floor(arr.length / 2);

        let pivot = arr.splice(pivotIndex, 1)[0];

        let left = [];

        let right = [];

        for (let i = 0; i < arr.length; i++){

            if (arr[i] < pivot) {

                left.push(arr[i]);

            } else {

                right.push(arr[i]);

            }

        }

        return quickSort(left).concat([pivot], quickSort(right));

    };
    // console.log(kxpx(arr1))

   /* let obj={1:1000,2:2000,5:5000};
    obj.length=13;
    let res=Array.from(obj).slice(1);
    console.log(res);
    let arr=[];
    res.filter((v,i)=>{if(v==undefined) v=null;
        arr.push(v)
    })
    console.log(arr)*/
</script>

